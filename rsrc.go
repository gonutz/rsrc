package main

import (
	"flag"
	"fmt"
	"os"
	"sort"

	"github.com/gonutz/rsrc/rsrc"
)

var usage = `USAGE:

%s [-manifest FILE.exe.manifest] [-ico FILE.ico[,FILE2.ico...]] -o FILE.syso
  Generates a .syso file with specified resources embedded in .rsrc section,
  aimed for consumption by Go linker when building Win32 excecutables.

The generated *.syso files should get automatically recognized by 'go build'
command and linked into an executable/library, as long as there are any *.go
files in the same directory.

If you build for multiple architectures, name your rsrc files accordingly, e.g.
rsrc_386.syso and rsrc_amd64.syso to have the Go compiler use the right one
depending on the current GOOS.

The mapping of input files to their resource IDs is printed as Go code to
stdout. You can save the output to a .go file which will contain a
  var exeIDs = map[string]uint16
which you can access at runtime to retrieve the resource ID for each embedded
file.

OPTIONS:
`

func main() {
	var manifest, icon, outPath, arch string
	flags := flag.NewFlagSet("", flag.ContinueOnError)
	flags.StringVar(&arch, "arch", "386", "architecture of output file - one of: 386, [EXPERIMENTAL: amd64]")
	flags.StringVar(&manifest, "manifest", "", "path to a Windows manifest file to embed")
	flags.StringVar(&icon, "ico", "", "comma-separated list of paths to .ico files to embed")
	flags.StringVar(&outPath, "o", "rsrc.syso", "name of output COFF (.res or .syso) file")
	_ = flags.Parse(os.Args[1:])
	if outPath == "" || (manifest == "" && icon == "") {
		fmt.Fprintf(os.Stderr, usage, os.Args[0])
		flags.PrintDefaults()
		os.Exit(1)
	}

	if manifest != "" || icon != "" {
		ids, err := rsrc.Embed(outPath, arch, manifest, icon)
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(2)
		}
		var idList byID
		for path, id := range ids {
			idList = append(idList, idFile{id: id, path: path})
		}
		sort.Sort(idList)
		fmt.Print(`// generated by github.com/gonutz/rsrc

package main

// exeIDs maps the original file names to their resource IDs when embedded in
// the executable.
var exeIDs = map[string]uint16{`)
		for _, id := range idList {
			fmt.Printf("\n\t\"%s\": %v,", id.path, id.id)
		}
		if len(ids) > 0 {
			fmt.Println()
		}
		fmt.Print("}\n")
	}
}

type idFile struct {
	id   uint16
	path string
}

type byID []idFile

func (x byID) Len() int           { return len(x) }
func (x byID) Less(i, j int) bool { return x[i].id < x[j].id }
func (x byID) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
