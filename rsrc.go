package main

import (
	"flag"
	"fmt"
	"os"
	"sort"

	"github.com/gonutz/rsrc/rsrc"
)

var usage = `USAGE:

%s [-manifest FILE.exe.manifest] [-ico FILE.ico[,FILE2.ico...]] -o FILE.syso
  Generates a .syso file with specified resources embedded in .rsrc section,
  aimed for consumption by Go linker when building Win32 excecutables.

The generated *.syso files should get automatically recognized by 'go build'
command and linked into an executable/library, as long as there are any *.go
files in the same directory.

If you build for multiple architectures, name your rsrc files accordingly, e.g.
rsrc_386.syso and rsrc_amd64.syso to have the Go compiler use the right one
depending on the current GOOS.

OPTIONS:
`

func main() {
	var manifest, icon, outPath, arch string
	flags := flag.NewFlagSet("", flag.ContinueOnError)
	flags.StringVar(&arch, "arch", "386", "architecture of output file - one of: 386, [EXPERIMENTAL: amd64]")
	flags.StringVar(&manifest, "manifest", "", "path to a Windows manifest file to embed")
	flags.StringVar(&icon, "ico", "", "comma-separated list of paths to .ico files to embed")
	flags.StringVar(&outPath, "o", "rsrc.syso", "name of output COFF (.res or .syso) file")
	_ = flags.Parse(os.Args[1:])
	if outPath == "" || (manifest == "" && icon == "") {
		fmt.Fprintf(os.Stderr, usage, os.Args[0])
		flags.PrintDefaults()
		os.Exit(1)
	}

	if manifest != "" || icon != "" {
		ids, err := rsrc.Embed(outPath, arch, manifest, icon)
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(2)
		}
		var idList byID
		for path, id := range ids {
			idList = append(idList, idFile{id: id, path: path})
		}
		sort.Sort(idList)
		fmt.Print(`// generated by github.com/gonutz/rsrc

package main

// exeIDs maps the original file names to their resource IDs when embedded in
// the executable.
var exeIDs = map[string]uint16{`)
		for _, id := range idList {
			fmt.Printf("\n\t\"%s\": %v,", id.path, id.id)
		}
		if len(ids) > 0 {
			fmt.Println()
		}
		fmt.Print("}\n")
	}
}

type idFile struct {
	id   uint16
	path string
}

type byID []idFile

func (x byID) Len() int           { return len(x) }
func (x byID) Less(i, j int) bool { return x[i].id < x[j].id }
func (x byID) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
